<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8" />
<title>聯絡簿系統（老師/管理員回覆私密）</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { font-family: "微軟正黑體", Arial, sans-serif; background:#f2f5fa; color:#222; padding:18px; text-align:center; }
  h1 { color:#2c3e50; }
  .btn { padding:8px 12px; border-radius:8px; border:none; background:#4285F4; color:white; cursor:pointer; margin:4px; }
  .btn:active{transform:translateY(1px)}
  textarea,input{ width:80%; max-width:480px; padding:8px; border-radius:6px; border:1px solid #ccc; }
  .note, .reply-box { background:#fff; padding:12px; border-radius:10px; margin:10px auto; box-shadow:0 2px 6px rgba(0,0,0,0.08); text-align:left; max-width:640px; }
  .reply-box { background:#fbfbfb; margin-left:28px; }
  small { color:#666; }
  .controls { margin-top:8px; }
  .meta { color:#666; font-size:13px; }
  .hidden { display:none; }
  .flex { display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap; }
  .tag { background:#eef5ff; color:#2b66d6; padding:2px 8px; border-radius:12px; font-size:12px; }
</style>
</head>
<body>
  <h1>📘 聯絡簿系統（含私密回覆）</h1>

  <div id="login-section">
    <button class="btn" onclick="googleLogin()">使用 Google 登入</button>
  </div>

  <div id="app" class="hidden">
    <p id="user-info"></p>
    <div class="flex">
      <button class="btn" onclick="logout()">登出</button>
    </div>

    <!-- 老師/管理員發佈 -->
    <div id="teacher-panel" class="hidden" style="margin-top:12px;">
      <h3>✏️ 發佈聯絡簿</h3>
      <textarea id="note" placeholder="輸入內容（Shift+Enter 換行）"></textarea><br>
      <div class="controls">
        <button class="btn" onclick="addNote()">發佈</button>
      </div>
    </div>

    <hr style="max-width:760px; margin:18px auto;">

    <h3>📜 聯絡簿</h3>
    <div id="notes"></div>

  </div>

<script type="module" defer>
/* --------------------------------------------
   聯絡簿：老師/管理員能刪除、編輯、回覆（回覆可 internal/private/public）
   私密回覆 private 只給該學生 + 老師/管理員看到
   replies 存在 notes/{noteId}/replies
----------------------------------------------*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import {
  getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
import {
  getFirestore, collection, addDoc, setDoc, doc, getDoc, getDocs,
  onSnapshot, deleteDoc, updateDoc, query, orderBy, serverTimestamp, where
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

// ---------- Firebase config（使用你給的專案） ----------
const firebaseConfig = {
  apiKey: "AIzaSyAPJ_QfW6IurPiSFg1yrcrr3eu2eoLMXqM",
  authDomain: "text-585a6.firebaseapp.com",
  projectId: "text-585a6",
  storageBucket: "text-585a6.firebasestorage.app",
  messagingSenderId: "789195223699",
  appId: "1:789195223699:web:847902083fb646bda25366",
  measurementId: "G-FL11M47EFP"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const provider = new GoogleAuthProvider();

let currentUser = null;
let currentRole = "student";

// ---------- 工具：格式化顯示（換行 + 連結） ----------
function formatTextForSave(text) {
  // 儲存 HTML-safe: 將 < > escape 後處理換行與連結
  const esc = text.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
  return esc.replace(/\n/g,"<br>").replace(/(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank">$1</a>');
}
function formatTextForDisplay(stored) {
  return stored; // 已是 HTML-safe + <br> + <a>
}

// ---------- 新增聯絡簿（老師/管理員） ----------
async function addNote() {
  if (currentRole !== "teacher" && currentRole !== "admin") {
    alert("只有老師或管理員可以發佈聯絡簿。");
    return;
  }
  const ta = document.getElementById("note");
  const raw = ta.value.trim();
  if (!raw) return alert("請輸入內容");
  await addDoc(collection(db, "notes"), {
    author: currentUser.displayName,
    email: currentUser.email,
    content: formatTextForSave(raw),
    createdAt: serverTimestamp(),
    createdAtStr: new Date().toLocaleString()
  });
  ta.value = "";
}

// ---------- 刪除聯絡簿（老師/管理員） ----------
async function deleteNoteConfirmed(noteId) {
  // 先讀取原內容、寫入 deleted_log，再刪除
  const noteRef = doc(db, "notes", noteId);
  const noteSnap = await getDoc(noteRef);
  if (!noteSnap.exists()) { alert("找不到該筆資料"); return; }
  const data = noteSnap.data();
  if (!confirm(`確定刪除此聯絡簿？\n\n${data.author} — ${data.createdAtStr}`)) return;

  // 寫入 deleted_log
  await addDoc(collection(db, "deleted_log"), {
    type: "note",
    noteId,
    originalAuthor: data.author,
    originalEmail: data.email,
    originalContent: data.content,
    originalTime: data.createdAtStr,
    deletedBy: currentUser.displayName,
    deletedByEmail: currentUser.email,
    deletedByRole: currentRole,
    deletedAt: new Date().toLocaleString()
  });

  // 刪除（注意：這不會刪 replies 子集合；若要一併刪可再擴充）
  await deleteDoc(noteRef);
}

// ---------- 編輯聯絡簿（老師/管理員） ----------
async function editNotePrompt(noteId) {
  const noteRef = doc(db, "notes", noteId);
  const snap = await getDoc(noteRef);
  if (!snap.exists()) { alert("找不到資料"); return; }
  const data = snap.data();
  // 將 stored HTML 轉回 plain 新輸入（簡單處理：把 <br> 換成 \n，去掉 a 標籤）
  const plain = data.content.replace(/<br>/g, "\n").replace(/<a[^>]*>([^<]*)<\/a>/g, "$1").replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&");
  const newText = prompt("編輯聯絡簿內容：", plain);
  if (newText === null) return;
  await updateDoc(noteRef, {
    content: formatTextForSave(newText),
    editedAt: new Date().toLocaleString(),
    editedBy: currentUser.displayName
  });
}

// ---------- 新增回覆（老師/管理員） ----------
/*
  replyVisibility:
    - "internal" : 只有老師/管理員看得到
    - "public"   : 所有人看得到
    - "private"  : 只有指定學生（toEmail）與老師/管理員看得到
*/
async function addReplyPrompt(noteId) {
  if (currentRole !== "teacher" && currentRole !== "admin") {
    alert("只有老師或管理員可以回覆。");
    return;
  }
  const text = prompt("輸入回覆內容（支援換行：輸入 \\n 代表換行，或在提示後再貼多行）：");
  if (text === null || text.trim() === "") return;
  // 讓老師選擇 visibility
  const vis = prompt("回覆可見性？輸入 internal / public / private（private 則需輸入學生 email）", "internal");
  if (!vis) return;
  let toEmail = "";
  if (vis === "private") {
    toEmail = prompt("請輸入要發給哪位學生的 Email（範例：student@example.com）");
    if (!toEmail) { alert("必須輸入學生 Email"); return; }
  }
  await addDoc(collection(db, "notes", noteId, "replies"), {
    author: currentUser.displayName,
    authorEmail: currentUser.email,
    content: formatTextForSave(text.replace(/\\n/g,"\n")),
    visibility: vis,
    toEmail: toEmail || "",
    createdAt: serverTimestamp(),
    createdAtStr: new Date().toLocaleString()
  });
}

// ---------- 刪除回覆（老師/管理員） ----------
async function deleteReplyConfirmed(noteId, replyId) {
  const replyRef = doc(db, "notes", noteId, "replies", replyId);
  const snap = await getDoc(replyRef);
  if (!snap.exists()) { alert("找不到留言"); return; }
  const data = snap.data();
  if (!confirm("確定刪除此回覆？")) return;
  // 記錄刪除到 deleted_log
  await addDoc(collection(db, "deleted_log"), {
    type: "reply",
    noteId,
    replyId,
    original: data,
    deletedBy: currentUser.displayName,
    deletedByEmail: currentUser.email,
    deletedByRole: currentRole,
    deletedAt: new Date().toLocaleString()
  });
  await deleteDoc(replyRef);
}

// ---------- 讀取並渲染聯絡簿與回覆（即時） ----------
function renderNotesRealtime() {
  const notesContainer = document.getElementById("notes");
  const q = query(collection(db, "notes"), orderBy("createdAt", "desc"));
  onSnapshot(q, async (snapshot) => {
    notesContainer.innerHTML = "";
    // 逐筆處理（包含抓 replies）
    for (const docItem of snapshot.docs) {
      const noteId = docItem.id;
      const note = docItem.data();
      // fetch replies (ordered)
      const repliesSnap = await getDocs(query(collection(db, "notes", noteId, "replies"), orderBy("createdAt","asc")));
      // build replies HTML respecting visibility:
      let repliesHTML = "";
      repliesSnap.forEach((r) => {
        const d = r.data();
        // decide whether current user can see this reply
        const isTeacherOrAdmin = (currentRole === "teacher" || currentRole === "admin");
        let visible = false;
        if (d.visibility === "public") visible = true;
        else if (d.visibility === "internal" && isTeacherOrAdmin) visible = true;
        else if (d.visibility === "private" && (isTeacherOrAdmin || (currentUser && currentUser.email === d.toEmail))) visible = true;

        if (visible) {
          const delBtn = (isTeacherOrAdmin) ? `<button onclick="deleteReplyConfirmed('${noteId}','${r.id}')">刪除回覆</button>` : "";
          repliesHTML += `
            <div class="reply-box">
              <div class="meta"><b>${d.author}</b> <span style="color:#999">(${d.authorEmail})</span> ${d.visibility==='private' ? `<span class="tag">私人</span>` : d.visibility==='internal' ? `<span class="tag">內部</span>` : `<span class="tag">公開</span>`}</div>
              <div>${formatTextForDisplay(d.content)}</div>
              <small>${d.createdAtStr || ""}</small>
              ${delBtn}
            </div>`;
        }
      });

      // actions for this note:
      const isTeacherOrAdmin = (currentRole === "teacher" || currentRole === "admin");
      const editBtn = isTeacherOrAdmin ? `<button onclick="editNotePrompt('${noteId}')">編輯</button>` : "";
      const delBtn = isTeacherOrAdmin ? `<button onclick="deleteNoteConfirmed('${noteId}')">刪除</button>` : "";
      const replyBtn = isTeacherOrAdmin ? `<button onclick="addReplyPrompt('${noteId}')">回覆</button>` : "";

      // Build note HTML
      notesContainer.innerHTML += `
        <div class="note">
          <div class="meta"><b>${note.author}</b> <span style="color:#999">(${note.email})</span></div>
          <div style="margin-top:6px;">${formatTextForDisplay(note.content)}</div>
          <small>${note.createdAtStr || ""} ${note.editedAt ? ` · 編輯於 ${note.editedAt}（${note.editedBy||""}）` : ""}</small>
          <div class="controls">${editBtn} ${delBtn} ${replyBtn}</div>
          ${repliesHTML}
        </div>`;
    }
  });
}

// ---------- helper: show admin deleted_log (管理員可看) ----------
function renderDeletedLogIfAdmin() {
  if (currentRole !== "admin") return;
  // 你可以新增一個管理頁面顯示 deleted_log；這裡只在 console 示範
  const q = query(collection(db, "deleted_log"), orderBy("deletedAt","desc"));
  onSnapshot(q, (snapshot) => {
    console.log("deleted_log updated:", snapshot.docs.map(d=>d.data()));
  });
}

// ---------- 監聽登入狀態 ----------
onAuthStateChanged(auth, async (user) => {
  const loginSection = document.getElementById("login-section");
  const appSection = document.getElementById("app");
  if (!loginSection || !appSection) return;

  if (user) {
    currentUser = user;
    // hide login, show app
    loginSection.classList.add("hidden");
    appSection.classList.remove("hidden");
    document.getElementById("user-info").innerText = `👋 歡迎 ${user.displayName} (${user.email})`;

    // ensure user role exists
    const userRef = doc(db, "users", user.email);
    const userSnap = await getDoc(userRef);
    if (!userSnap.exists()) {
      const role = (user.email === "chianghansen0302@gmail.com") ? "admin" : "student";
      await setDoc(userRef, { role });
      currentRole = role;
    } else {
      currentRole = userSnap.data().role || "student";
    }

    // teacher panel visible?
    if (currentRole === "teacher" || currentRole === "admin") {
      document.getElementById("teacher-panel").classList.remove("hidden");
    }

    // start realtime render
    renderNotesRealtime();
    renderNotesRealtime = renderNotesRealtime; // no-op to keep linter happy
    renderNotesRealtime(); // immediate call

    renderNotesRealtime = renderNotesRealtime; // keep reference
    // But we have function renderNotesRealtime defined earlier; call it:
    // (Note: we already called above)
    // Also render deleted_log if admin
    renderDeletedLogIfAdmin();
  }
});

// ---------- Enter / Shift+Enter 行為（全域） ----------
document.addEventListener("keydown", (e) => {
  const el = document.activeElement;
  if (!el) return;
  if (el.tagName === "TEXTAREA" && e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    // 判斷是哪個 textarea
    if (el.id === "note") {
      addNote();
    } else if (el.id === "chat-input") {
      // not used here — chat is separate file in your setup
    } else if (el.id && el.id.startsWith("reply-")) {
      // 以 internal reply via inline textarea — but we used prompt-based replies above,
      // for inline replies you'd implement addReply(noteId) reading from that textarea.
    }
  }
});

// ---------- 公開函式綁到 window（供 HTML button 使用） ----------
window.googleLogin = async () => {
  try { await signInWithPopup(auth, provider); }
  catch (err) { alert("登入失敗：" + err.message); }
};
window.logout = async () => { await signOut(auth); location.reload(); };
window.addNote = addNote;
window.addReplyPrompt = addReplyPrompt;
window.deleteNoteConfirmed = deleteNoteConfirmed;
window.editNotePrompt = editNotePrompt;
window.deleteReplyConfirmed = deleteReplyConfirmed;

// 將 formatTextForDisplay 暴露（上面使用）
window.formatTextForDisplay = formatTextForDisplay;

</script>
</body>
</html>
